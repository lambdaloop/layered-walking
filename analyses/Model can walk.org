#+TITLE: Model Can Walk

* Goal

The goal of this notebook is to make plots for Figure 2 of the paper. Namely:
- An example trajectory
- Phase angle plot comparisons
- Angle error
- Phase coupling within a leg
- Phase coupling across legs
- Step frequency distributions
- Demo videos

The network should be set up so that running it from top to bottom makes all the figure sublayouts.

* Setup

#+BEGIN_SRC jupyter-python
import numpy as np
import statsmodels.api as sm
from statsmodels.sandbox.regression.predstd import wls_prediction_std
import matplotlib.pyplot as plt
import os
from tqdm import tqdm, trange
import pandas as pd
from scipy import signal
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
import sys
project_path = "/home/pierre/research/tuthill/layered-walking"
sys.path.append(project_path)
from tools.angle_functions import anglesTG as angle_names_1leg
from tools.angle_functions import legs
from tools.angle_functions import make_fly_video, angles_to_pose_names
from tools.trajgen_tools import WalkingData
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
import matplotlib.pyplot as plt
import seaborn as sns
%matplotlib inline

plt.style.use('default')
plt.rcParams['figure.figsize'] = (7.5, 2)
#+END_SRC


#+RESULTS:

#+BEGIN_SRC jupyter-python
xvals = np.linspace(-np.pi, np.pi)
def get_phase(ang):
    m = np.median(ang, axis=0)
    s = np.std(ang, axis=0)
    s[s == 0] = 1
    dm = (ang - m) / s
    phase = np.arctan2(-dm[:,1], dm[:,0])
    return phase

def phase_align_poly(ang, extra=None, order=5):
    topredict = ang
    if extra is not None:
        topredict = np.hstack([ang, extra])
    means = np.full((len(xvals), topredict.shape[1]), np.nan)
    stds = np.full((len(xvals), topredict.shape[1]), np.nan)
    if len(ang) < 50: # not enough data
        return means, stds
    phase = get_phase(ang)
    # pcs = np.vstack([np.cos(phase), np.sin(phase)]).T
    b = np.vstack([np.cos(i * phase + j) for i in range(order) for j in [0, np.pi/2]]).T
    xcs = np.vstack([np.cos(i * xvals + j) for i in range(order) for j in [0, np.pi/2]]).T
    for i in range(topredict.shape[1]):
        cc = np.isfinite(topredict[:,i])
        model = sm.OLS(topredict[cc,i], b[cc]).fit()
        means[:,i] = model.predict(xcs)
        s, upper,lower = wls_prediction_std(model, xcs)
        stds[:,i] = s
    return means, stds

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
# list(d.keys())
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
fname = os.path.join(project_path, 'output', 'control_stats_v13.npz')
d = np.load(fname, allow_pickle=True)

conditions = d['conditions'][()]
angles = d['angleTG']
derivs = d['drvTG']
poses = d['pose_3d']
accels = signal.savgol_filter(derivs, 5, 2, deriv=1, axis=3)


speeds = np.array([x['context'] for x in conditions])

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
poses.shape
#+END_SRC

#+RESULTS:
| 500 | 600 | 6 | 5 | 3 |


#+BEGIN_SRC jupyter-python
fname = '/home/pierre/data/tuthill/models/models_sls/walk_sls_legs_13.pickle'
wd = WalkingData(fname)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
wd.bout_context
#+END_SRC

#+RESULTS:
: array([[ 9.968394 , -0.2343701,  2.8402553],
:        [ 5.0455656,  8.416804 , -0.6643358],
:        [ 8.86242  ,  8.355217 , -1.4570035],
:        ...,
:        [ 9.824624 ,  3.8363965,  2.475409 ],
:        [13.015    , -0.6182214,  1.8810371],
:        [ 6.7187276, -3.0979152,  2.84063  ]], dtype=float32)

* Example time series

For the figure part A, we'd like to have multiple example angles. Perhaps R1 femur-tibia flexion would be good to show, but also L2 femur rotation?
I'd like to have multiple traces for each angle, perhaps we could show with forward, rotation, and sideslip?

In this code, we could also make a supplementary figure with a more complete set of angles.

** Real tracking

Parameters for both angles
#+BEGIN_SRC jupyter-python
plot_speeds = [[8, 0, 0], [12, 0, 0], [16, 0, 0]]
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
angname = 'C_flex'
leg = 'R1'
ix_ang = angle_names_1leg.index(angname)
ix_leg = legs.index(leg)

plt.figure(figsize=(9, 2.5))
for i in range(len(plot_speeds)):
    plt.subplot(3, 1, i+1)
    ww = wd.get_bout(plot_speeds[i], offset=2)
    ang = ww['angles'][leg][:, ix_ang]
    t = np.arange(len(ang))/300.0
    plt.plot(t, ang)
    plt.ylim(30, 160)
    plt.yticks([60, 120])
    if i != 2:
        plt.xticks(ticks=[])

sns.despine(bottom=True)

plt.ylabel("Angle (deg)")
plt.xlabel("Time (s)")
plt.savefig('plots/fig2A_trace_real_{}{}.pdf'.format(leg, angname))
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/fd3c99c68fc54d47ce263fe288b1f9cb261e51e6.png]]


#+BEGIN_SRC jupyter-python
angname = 'B_rot'
leg = 'R2'
ix_ang = angle_names_1leg.index(angname)
ix_leg = legs.index(leg)

plt.figure(figsize=(9, 2.5))
for i in range(len(plot_speeds)):
    plt.subplot(3, 1, i+1)
    ww = wd.get_bout(plot_speeds[i], offset=2)
    ang = ww['angles'][leg][:, ix_ang].copy()
    t = np.arange(len(ang))/300.0
    ang[ang > 50] -= 360
    ang += 360
    plt.plot(t, ang)
    plt.ylim(170, 230)
    plt.yticks([180, 210])
    if i != 2:
        plt.xticks(ticks=[])

sns.despine(bottom=True)

plt.ylabel("Angle (deg)")
plt.xlabel("Time (s)")
plt.savefig('plots/fig2A_trace_real_{}{}.pdf'.format(leg, angname))
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/d2c502595f213de721f92bfdebfc979759bce712.png]]


* Phase plots

Load the simulated data
#+BEGIN_SRC jupyter-python
ds = []
for i in trange(len(speeds), ncols=70):
    for ix_leg, leg in enumerate(legs):
        for ix_ang, angname in enumerate(angle_names_1leg):
            forward, rot, side = speeds[i]
            x = np.vstack([angles[i, ix_leg, ix_ang, :],
                           derivs[i, ix_leg, ix_ang, :]]).T
            c = np.all(np.isfinite(x), axis=1)
            x = x[c]
            means, stds = phase_align_poly(
                x, extra=accels[i, ix_leg, ix_ang, :, None])
            d = pd.DataFrame(np.hstack([xvals[:,None],means]),
                             columns=['phase', 'angle', 'deriv', 'accel'])
            d['speed_forward'] = forward
            d['speed_rotation'] = rot
            d['speed_side'] = side
            d['angle_name'] = angname
            d['leg'] = leg
            d['type'] = 'simulated'
            ds.append(d)
allangf = pd.concat(ds).reset_index(drop=True)
#+END_SRC

#+RESULTS:
: 100%|███████████████████████████████| 500/500 [01:00<00:00,  8.29it/s]


Load the real data
#+BEGIN_SRC jupyter-python
ds = []
bnums = wd._get_minlen_bnums(400)
for i in trange(len(bnums), ncols=70):
    bnum = bnums[i]
    ww = wd.get_bnum(bnum)
    mean_speed = np.mean(ww['contexts'], axis=0)
    forward, rot, side = mean_speed
    for ix_leg, leg in enumerate(legs):
        for ix_ang, angname in enumerate(angle_names_1leg):
            angs = ww['angles'][leg][:, ix_ang]
            drvs = ww['derivatives'][leg][:, ix_ang]
            accels = signal.savgol_filter(drvs, 5, 2, deriv=1)
            x = np.vstack([angs, drvs]).T
            c = np.all(np.isfinite(x), axis=1)
            x = x[c]
            means, stds = phase_align_poly(
                x, extra=accels[:,None])
            d = pd.DataFrame(np.hstack([xvals[:,None],means]),
                             columns=['phase', 'angle', 'deriv', 'accel'])
            d['speed_forward_raw'] = forward
            d['speed_rotation_raw'] = rot
            d['speed_side_raw'] = side
            d['angle_name'] = angname
            d['leg'] = leg
            d['bnum'] = bnum
            d['type'] = 'real'
            ds.append(d)
realangf = pd.concat(ds).reset_index(drop=True)

realangf['speed_forward'] = ((realangf['speed_forward_raw'] + 2) // 4) * 4
realangf['speed_rotation'] = ((realangf['speed_rotation_raw'] + 2) // 4) * 4
realangf['speed_side'] = ((realangf['speed_side_raw'] + 1) // 2) * 2

realangf['speed_forward'] = realangf['speed_forward'].astype('int')
realangf['speed_rotation'] = realangf['speed_rotation'].astype('int')
realangf['speed_side'] = realangf['speed_side'].astype('int')
#+END_SRC

#+RESULTS:
: 100%|███████████████████████████████| 171/171 [00:23<00:00,  7.20it/s]

#+BEGIN_SRC jupyter-python
fullangf = pd.concat([allangf, realangf]).reset_index(drop=True)
#+END_SRC

#+RESULTS:

#+RESULTS:

#+BEGIN_SRC jupyter-python
_ = plt.hist(dd['speed_rotation_raw'], bins=20)
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/40b449ef41ecf574e3c1a0f69b9d1f1492212790.png]]


#+BEGIN_SRC jupyter-python
leg = 'R1'
angname = 'C_flex'

dd = fullangf
c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 1) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="angle", hue="type",
                estimator=np.mean, err_style='band', ci=95,
                col="speed_forward", kind="line", height=3, aspect=0.8)

c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 1) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="deriv", hue="type",
                estimator=np.mean, err_style='band', ci=95,
                col="speed_forward", kind="line", height=3, aspect=0.8)

c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 1) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="accel", hue="type",
                estimator=np.mean, err_style='band', ci=95,
                col="speed_forward", kind="line", height=3, aspect=0.8)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/41f8e4136096114a28ea17bd878408ceccc30986.png]]
[[file:./.ob-jupyter/bc29202a99105c7dca86939621ea65d896b85955.png]]
[[file:./.ob-jupyter/a886106602b11dcd5e333f4375d93a8ef4e78ff5.png]]
:END:

#+BEGIN_SRC jupyter-python
leg = 'L2'
angname = 'B_rot'

dd = fullangf
c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 1) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="angle", hue="type",
                estimator=np.mean, err_style='band', ci=95,
                col="speed_forward", kind="line", height=3, aspect=0.8)

c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 1) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="deriv", hue="type",
                estimator=np.mean, err_style='band', ci=95,
                col="speed_forward", kind="line", height=3, aspect=0.8)

c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 1) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="accel", hue="type",
                estimator=np.mean, err_style='band', ci=95,
                col="speed_forward", kind="line", height=3, aspect=0.8)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/f502a31f8570fd4a3046e3593d1730e30bbcf98f.png]]
[[file:./.ob-jupyter/5a4c0cbf8e3f7be5c30daabed0556b0ef2b35cbb.png]]
[[file:./.ob-jupyter/2bc6df70a2aed64552f7430a87db7838307c2665.png]]
:END:


* Angle errors

#+BEGIN_SRC jupyter-python
def circular_mean(x):
    return np.degrees(np.angle(np.nanmean(np.exp(1j * np.radians(x)))))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
columns = ['leg', 'speed_forward', 'speed_rotation', 'speed_side', 'angle_name', 'phase']

ds = []
for var in ['angle', 'deriv', 'accel']:
    print(var)
    if var == 'angle':
        mean_fun = circular_mean
    else:
        mean_fun = np.nanmean
    sd = allangf.groupby(columns)[var].agg(mean_fun)
    rd = realangf.groupby(columns)[var].agg(mean_fun)
    out = sd - rd
    errors = out.reset_index().groupby(columns[:-1])[var]\
                              .agg(lambda x: np.abs(mean_fun(np.abs(x))))
    errors = errors.reset_index()
    errors = errors[~errors[var].isnull()]
    ds.append(errors)

angle_errors = pd.merge(pd.merge(ds[0], ds[1]), ds[2])

fancy_angle_names = {
    'C_flex': 'femur-tibia\nflexion',
    'A_rot': 'coxa\nrotation',
    'A_abduct': 'body-coxa\nflexion',
    'B_flex': 'coxa-femur\nflexion',
    'B_rot': 'femur\nrotation'
}
angle_errors['fancy_angle_name'] = [fancy_angle_names[x] for x in angle_errors['angle_name']]

angle_errors['deriv_units'] = angle_errors['deriv'] * 300.0
angle_errors['accel_units'] = angle_errors['accel'] * 300.0 * 300.0
#+END_SRC

#+RESULTS:
: angle
: /tmp/ipykernel_3062741/855530367.py:2: RuntimeWarning: Mean of empty slice
:   return np.degrees(np.angle(np.nanmean(np.exp(1j * np.radians(x)))))
: deriv
: /tmp/ipykernel_3062741/4098378410.py:14: RuntimeWarning: Mean of empty slice
:   .agg(lambda x: np.abs(mean_fun(np.abs(x))))
: accel
: /tmp/ipykernel_3062741/4098378410.py:14: RuntimeWarning: Mean of empty slice
:   .agg(lambda x: np.abs(mean_fun(np.abs(x))))


#+BEGIN_SRC jupyter-python
plt.figure()
g = sns.violinplot(x='fancy_angle_name', y='angle', data=angle_errors)
g.set(xlabel='Angle', ylabel='Angle error (deg)')

plt.figure()
g = sns.violinplot(x='fancy_angle_name', y='deriv_units', data=angle_errors)
g.set(xlabel='Angle', ylabel='Derivative error (deg/s)')

plt.figure()
g = sns.violinplot(x='fancy_angle_name', y='accel_units', data=angle_errors)
g.set(xlabel='Angle', ylabel='Acceleration error (deg/s^2)')
#+END_SRC

#+RESULTS:
:RESULTS:
| Text | (0.5 0 Angle) | Text | (0 0.5 Acceleration error (deg/s^2)) |
[[file:./.ob-jupyter/be2fe92c65235b58755c2216b49e5d3da1a3343f.png]]
[[file:./.ob-jupyter/5d461c7da0d974db62282d739e1146c4bf39f5fa.png]]
[[file:./.ob-jupyter/91c6c2c5f64d00c6fcf73918110057250b1328ab.png]]
:END:
