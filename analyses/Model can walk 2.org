#+TITLE: Model Can Walk

* Goal

The goal of this notebook is to make plots for Figure 2 of the paper. Namely:
- An example trajectory
- Phase angle plot comparisons
- Angle error
- Phase coupling within a leg
- Phase coupling across legs
- Step frequency distributions
- Demo videos

The network should be set up so that running it from top to bottom makes all the figure sublayouts.

* Setup

#+BEGIN_SRC jupyter-python
import numpy as np
import statsmodels.api as sm
from statsmodels.sandbox.regression.predstd import wls_prediction_std
import matplotlib.pyplot as plt
import os
from tqdm import tqdm, trange
import pandas as pd
from scipy import signal, stats
import pickle
from glob import glob
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
import sys
project_path = "/home/lili/research/tuthill/layered-walking"
data_path = '/home/lili/data/tuthill/models/sls_runs'
sys.path.append(project_path)
from tools.angle_functions import anglesTG as angle_names_1leg
from tools.angle_functions import legs
from tools.angle_functions import make_fly_video, angles_to_pose_names
from tools.trajgen_tools import WalkingData
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
import matplotlib.pyplot as plt
import seaborn as sns
%matplotlib inline

plt.style.use('default')
plt.rcParams['figure.figsize'] = (7.5, 2)
#+END_SRC


#+RESULTS:

#+BEGIN_SRC jupyter-python
xvals = np.linspace(-np.pi, np.pi)
def get_phase(ang):
    m = np.median(ang, axis=0)
    s = np.std(ang, axis=0)
    s[s == 0] = 1
    dm = (ang - m) / s
    phase = np.arctan2(-dm[:,1], dm[:,0])
    return phase

def phase_align_poly(ang, extra=None, order=5):
    topredict = ang
    if extra is not None:
        topredict = np.hstack([ang, extra])
    means = np.full((len(xvals), topredict.shape[1]), np.nan)
    stds = np.full((len(xvals), topredict.shape[1]), np.nan)
    if len(ang) < 50: # not enough data
        return means, stds
    phase = get_phase(ang)
    # pcs = np.vstack([np.cos(phase), np.sin(phase)]).T
    b = np.vstack([np.cos(i * phase + j) for i in range(order) for j in [0, np.pi/2]]).T
    xcs = np.vstack([np.cos(i * xvals + j) for i in range(order) for j in [0, np.pi/2]]).T
    for i in range(topredict.shape[1]):
        cc = np.isfinite(topredict[:,i])
        model = sm.OLS(topredict[cc,i], b[cc]).fit()
        means[:,i] = model.predict(xcs)
        s, upper,lower = wls_prediction_std(model, xcs)
        stds[:,i] = s
    return means, stds

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
# list(d.keys())
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
# fname_pat = os.path.join(data_path, 'delays_stats_subang_v2_actuate_gaussian_*.npz')
fname_pat = os.path.join(data_path, 'stats_subang_v5_nodist_*.pkl')
fnames = sorted(glob(fname_pat))

conditions = []
angles = []
derivs = []
accels = []
phasesTG = []

for fname in tqdm(fnames, ncols=70):
    # d = np.load(fname, allow_pickle=True)
    with open(fname, 'rb') as f:
        d = pickle.load(f)

    angle_names = d['angleNames'][0]

    for i, cond in enumerate(d['conditions']):
        ang = d['angle'][i]
        deriv = signal.savgol_filter(ang, 5, 2, deriv=1, axis=0)
        accel = signal.savgol_filter(deriv, 5, 2, deriv=1, axis=0)
        conditions.append(cond)
        angles.append(ang)
        derivs.append(deriv)
        accels.append(accel)
        phasesTG.append(d['phaseTG'][i])
#+END_SRC

#+RESULTS:
: 100%|█████████████████████████████████| 52/52 [00:12<00:00,  4.01it/s]
:

#+BEGIN_SRC jupyter-python
accels[0]
#+END_SRC

#+RESULTS:
#+begin_example
array([[ 0.02237683, -1.04705735, -0.0334956 , ..., -0.25130772,
        -0.48072441,  0.17590914],
       [ 0.05304825, -0.94203876, -0.07709571, ..., -0.20930985,
        -0.43367159,  0.1362899 ],
       [ 0.08371966, -0.83702018, -0.12069583, ..., -0.16731198,
        -0.38661878,  0.09667067],
       ...,
       [ 0.01745667, -0.01273886,  0.0122177 , ..., -0.1306441 ,
         0.08310148, -0.1763693 ],
       [ 0.03543241, -0.00465501,  0.04434183, ..., -0.14527406,
         0.0882531 , -0.21103469],
       [ 0.05340814,  0.00342884,  0.07646596, ..., -0.15990401,
         0.09340473, -0.24570008]])
#+end_example


#+BEGIN_SRC jupyter-python
speeds = np.array([x['context'] for x in conditions])
angle_names = list(angle_names)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
fname = '/home/lili/data/tuthill/models/models_sls/walk_sls_legs_subang_6.pickle'
wd = WalkingData(fname)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
wd.bout_context
#+END_SRC

#+RESULTS:
: array([[ 3.4748168, 18.434208 ,  2.642376 ],
:        [ 1.0033004, 20.97231  ,  3.094752 ],
:        [ 1.4011644, 11.787567 ,  2.894012 ],
:        ...,
:        [ 9.824624 ,  3.8363965,  2.475409 ],
:        [13.015    , -0.6182214,  1.8810371],
:        [ 6.7187276, -3.0979152,  2.84063  ]], dtype=float32)

#+BEGIN_SRC jupyter-python
fancy_angle_names = {
    'C_flex': 'femur-tibia\nflexion',
    'A_rot': 'coxa\nrotation',
    'A_abduct': 'body-coxa\nflexion',
    'B_flex': 'coxa-femur\nflexion',
    'B_rot': 'femur\nrotation'
}
#+END_SRC

#+RESULTS:

* Figure 2
** Example time series

For the figure 2 part A, we'd like to have multiple example angles. Perhaps R1 femur-tibia flexion would be good to show, but also L2 femur rotation?
I'd like to have multiple traces for each angle, perhaps we could show with forward, rotation, and sideslip?

In this code, we could also make a supplementary figure with a more complete set of angles.

*** Real tracking

Parameters for both angles
#+BEGIN_SRC jupyter-python
plot_speeds = [[8, 0, 0], [10, 0, 0], [12, 0, 0]]
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
angname = 'C_flex'
leg = 'R1'
# ix_ang = angle_names_1leg.index(angname)
ix_ang = wd._angle_names[leg].index(leg + angname)
ix_leg = legs.index(leg)

plt.figure(figsize=(9, 2.5))
for i in range(len(plot_speeds)):
    plt.subplot(3, 1, i+1)
    ww = wd.get_bout(plot_speeds[i], offset=0)
    ang = ww['angles'][leg][:, ix_ang]
    t = np.arange(len(ang))/300.0
    plt.plot(t, ang, color="#FF7F0E")
    plt.ylim(30, 160)
    plt.yticks([60, 120])
    if i != 2:
        plt.xticks(ticks=[])

sns.despine(bottom=True)

plt.ylabel("Angle (deg)")
plt.xlabel("Time (s)")
plt.savefig('plots/fig2A_trace_real_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/a3c7032a59efb8544cab50ea8b897577eadcad33.png]]


#+BEGIN_SRC jupyter-python
angname = 'B_rot'
leg = 'L2'
# ix_ang = angle_names_1leg.index(angname)
ix_ang = wd._angle_names[leg].index(leg + angname)
ix_leg = legs.index(leg)

plt.figure(figsize=(9, 2.5))
for i in range(len(plot_speeds)):
    plt.subplot(3, 1, i+1)
    ww = wd.get_bout(plot_speeds[i], offset=2)
    ang = ww['angles'][leg][:, ix_ang].copy()
    t = np.arange(len(ang))/300.0
    ang[ang > 50] -= 360
    ang += 360
    plt.plot(t, ang, color="#FF7F0E")
    plt.ylim(110, 160)
    plt.yticks([120, 150])
    if i != 2:
        plt.xticks(ticks=[])

sns.despine(bottom=True)

plt.ylabel("Angle (deg)")
plt.xlabel("Time (s)")
plt.savefig('plots/fig2A_trace_real_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/9c902d6d31d1e3bfdcb62631b2fe885898395b99.png]]


*** Simulated plots

#+BEGIN_SRC jupyter-python
angname = 'C_flex'
leg = 'R1'
ix_ang = angle_names.index(leg + angname)

plt.figure(figsize=(9, 2.5))
for i in range(len(plot_speeds)):
    plt.subplot(3, 1, i+1)
    ixs = np.where(np.all(speeds == plot_speeds[i], axis=1))[0]
    ix_bout = ixs[0]
    ang = angles[ix_bout][:, ix_ang]
    t = np.arange(len(ang))/300.0
    plt.plot(t[:600], ang[:600])
    plt.ylim(30, 160)
    plt.yticks([60, 120])
    if i != 2:
        plt.xticks(ticks=[])

sns.despine(bottom=True)

plt.ylabel("Angle (deg)")
plt.xlabel("Time (s)")

plt.savefig('plots/fig2A_trace_simulated_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/9f7b1d9150639946cd7a70c3b7df60fc594272a6.png]]


#+BEGIN_SRC jupyter-python
angname = 'B_rot'
leg = 'L2'
ix_ang = angle_names.index(leg + angname)

plt.figure(figsize=(9, 2.5))
for i in range(len(plot_speeds)):
    plt.subplot(3, 1, i+1)
    ixs = np.where(np.all(speeds == plot_speeds[i], axis=1))[0]
    ix_bout = ixs[0]
    ang = angles[ix_bout][:, ix_ang]
    t = np.arange(len(ang))/300.0
    plt.plot(t[:600], ang[:600])
    plt.ylim(110, 160)
    plt.yticks([120, 150])
    if i != 2:
        plt.xticks(ticks=[])

sns.despine(bottom=True)

plt.ylabel("Angle (deg)")
plt.xlabel("Time (s)")

plt.savefig('plots/fig2A_trace_simulated_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/482e7c07d8624d9a1381b795c78f24e23003bdd3.png]]


** Videos for example series

Here, we make some videos corresponding to the example time series, for visualizing all of the angles at the same time.

#+BEGIN_SRC jupyter-python
video_speeds = [
    [8, 0, 0], [10, 0, 0], [12, 0, 0], [14, 0, 0],
    [12, -8, 0], [12, 8, 0],
    [12, 0, -4], [12, 0, 4]
]
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
def format_speed(speed):
    return '_'.join([str(x) for x in speed])
#+END_SRC

#+RESULTS:

Simulated videos
#+BEGIN_SRC jupyter-python
for i, speed in enumerate(video_speeds):
    print(speed)
    ixs = np.where(np.all(speeds == speed, axis=1))[0]
    ix_bout = ixs[0]
    pose = angles_to_pose_names(angles[ix_bout], angle_names)
    make_fly_video(pose, 'vids/simulated_fly_{}.mp4'.format(format_speed(speed)))
plt.close('all')
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
[8, 0, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 900/900 [00:20<00:00, 43.89it/s]

100%|█████████████████████████████████████████████████████████████████████████████████████████| 900/900 [00:19<00:00, 45.56it/s]

[12, 0, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 900/900 [00:19<00:00, 45.53it/s]

[14, 0, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 900/900 [00:20<00:00, 44.56it/s]
[12, -8, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 900/900 [00:19<00:00, 46.70it/s]
[12, 8, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 900/900 [00:19<00:00, 45.62it/s]
[12, 0, -4]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 900/900 [00:19<00:00, 46.83it/s]
[12, 0, 4]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 900/900 [00:19<00:00, 46.41it/s]
#+end_example
:END:



#+BEGIN_SRC jupyter-python
for i, speed in enumerate(video_speeds):
    print(speed)
    ww = wd.get_bout(video_speeds[i], offset=0)
    out = []
    angnames = []
    for leg in legs:
        ang = ww['angles'][leg]
        out.append(ang)
        angnames.extend(wd._angle_names[leg])
    ang = np.hstack(out)
    pose = angles_to_pose_names(ang, angnames)
    make_fly_video(pose, 'vids/real_fly_{}.mp4'.format(format_speed(speed)))
plt.close('all')
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
[8, 0, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 600/600 [00:12<00:00, 46.81it/s]

100%|█████████████████████████████████████████████████████████████████████████████████████████| 600/600 [00:12<00:00, 46.54it/s]

[12, 0, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 600/600 [00:13<00:00, 44.58it/s]

[14, 0, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 600/600 [00:13<00:00, 46.14it/s]
[12, -8, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 540/540 [00:12<00:00, 44.31it/s]
[12, 8, 0]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 600/600 [00:12<00:00, 46.28it/s]
[12, 0, -4]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 600/600 [00:13<00:00, 45.12it/s]
[12, 0, 4]
100%|█████████████████████████████████████████████████████████████████████████████████████████| 600/600 [00:13<00:00, 43.49it/s]
#+end_example
:END:


** Phase angle plots

In this set, I'll plot some angles of phase vs angle

Load the simulated data
#+BEGIN_SRC jupyter-python
ds = []
for i in trange(len(speeds), ncols=70):
    for ix_ang, angname in enumerate(angle_names):
        leg = angname[:2]
        forward, rot, side = speeds[i]
        x = np.vstack([angles[i][:, ix_ang],
                       derivs[i][:, ix_ang]]).T
        c = np.all(np.isfinite(x), axis=1)
        x = x[c]
        means, stds = phase_align_poly(
            x, extra=accels[i][c, ix_ang, None])
        d = pd.DataFrame(np.hstack([xvals[:,None],means]),
                         columns=['phase', 'angle', 'deriv', 'accel'])
        d['speed_forward'] = forward
        d['speed_rotation'] = rot
        d['speed_side'] = side
        d['angle_name'] = angname[2:]
        d['leg'] = leg
        d['type'] = 'simulated'
        ds.append(d)
allangf = pd.concat(ds).reset_index(drop=True)
#+END_SRC

#+RESULTS:
: 100%|█████████████████████████████| 1540/1540 [01:48<00:00, 14.16it/s]
:


Load the real data
#+BEGIN_SRC jupyter-python
ds = []
bnums = wd._get_minlen_bnums(400)
for i in trange(len(bnums), ncols=70):
    bnum = bnums[i]
    ww = wd.get_bnum(bnum)
    mean_speed = np.mean(ww['contexts'], axis=0)
    forward, rot, side = mean_speed
    for ix_leg, leg in enumerate(legs):
        for ix_ang, angname in enumerate(wd._angle_names[leg]):
            angs = ww['angles'][leg][:, ix_ang]
            drvs = ww['derivatives'][leg][:, ix_ang]
            acls = signal.savgol_filter(drvs, 5, 2, deriv=1)
            x = np.vstack([angs, drvs]).T
            c = np.all(np.isfinite(x), axis=1)
            x = x[c]
            means, stds = phase_align_poly(
                x, extra=acls[:,None])
            d = pd.DataFrame(np.hstack([xvals[:,None],means]),
                             columns=['phase', 'angle', 'deriv', 'accel'])
            d['speed_forward_raw'] = forward
            d['speed_rotation_raw'] = rot
            d['speed_side_raw'] = side
            d['angle_name'] = angname[2:]
            d['leg'] = leg
            d['bnum'] = bnum
            d['type'] = 'real'
            ds.append(d)
realangf = pd.concat(ds).reset_index(drop=True)

realangf['speed_forward'] = ((realangf['speed_forward_raw'] + 2) // 2) * 2
realangf['speed_rotation'] = ((realangf['speed_rotation_raw'] + 2) // 4) * 4
realangf['speed_side'] = ((realangf['speed_side_raw'] + 1) // 2) * 2

realangf['speed_forward'] = realangf['speed_forward'].astype('int')
realangf['speed_rotation'] = realangf['speed_rotation'].astype('int')
realangf['speed_side'] = realangf['speed_side'].astype('int')
#+END_SRC

#+RESULTS:
: 100%|███████████████████████████████| 173/173 [00:12<00:00, 13.52it/s]
:

#+BEGIN_SRC jupyter-python
fullangf = pd.concat([allangf, realangf]).reset_index(drop=True)
#+END_SRC

#+RESULTS:

#+RESULTS:

#+BEGIN_SRC jupyter-python
fullangf['deriv_units'] = fullangf['deriv'] * 300.0
fullangf['accel_units'] = fullangf['accel'] * 300.0 * 300.0
#+END_SRC

#+RESULTS:




#+BEGIN_SRC jupyter-python
leg = 'R1'
angname = 'C_flex'

dd = fullangf
c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 5) & (dd['speed_forward'] < 15) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="angle", hue="type",
                estimator=np.mean, err_style='band', errorbar=('ci', 95),
                col="speed_forward", kind="line", height=3, aspect=0.8)
g.set(ylabel="Angle (deg)")
plt.savefig('plots/fig2B_phase_angle_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")

c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 5) & (dd['speed_forward'] < 15) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="deriv_units", hue="type",
                estimator=np.mean, err_style='band', errorbar=('ci', 95),
                col="speed_forward", kind="line", height=3, aspect=0.8)
g.set(ylabel="Derivative (deg/s)")
plt.savefig('plots/fig2B_phase_deriv_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")

c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 5) & (dd['speed_forward'] < 15) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="accel_units", hue="type",
                estimator=np.mean, err_style='band', errorbar=('ci', 95),
                col="speed_forward", kind="line", height=3, aspect=0.8)
g.set(ylabel="Acceleration (deg/s^2)")
plt.savefig('plots/fig2B_phase_accel_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")

#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/ffe63a2d8c2b96cdd25c5fdf8678937a159f7d62.png]]
[[file:./.ob-jupyter/62b080ea5d55de4d1aa23d4088d70a1580eddd22.png]]
[[file:./.ob-jupyter/0235c94faf73ce7c490653e246c1fd791446ae6c.png]]
:END:


#+BEGIN_SRC jupyter-python
leg = 'L2'
angname = 'B_rot'

dd = fullangf
c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 5) & (dd['speed_forward'] < 15) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="angle", hue="type",
                estimator=np.mean, err_style='band', errorbar=('ci', 95),
                col="speed_forward", kind="line", height=3, aspect=0.8)
g.set(ylabel="Angle (deg)")
plt.savefig('plots/fig2B_phase_angle_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")

c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 5) & (dd['speed_forward'] < 15) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="deriv_units", hue="type",
                estimator=np.mean, err_style='band', errorbar=('ci', 95),
                col="speed_forward", kind="line", height=3, aspect=0.8)
g.set(ylabel="Derivative (deg/s)")
plt.savefig('plots/fig2B_phase_deriv_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")

c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
    & (dd['speed_forward'] > 5) & (dd['speed_forward'] < 15) \
    & (dd['angle_name'] == angname) & (dd['leg'] == leg)
g = sns.relplot(data=dd[c], x="phase", y="accel_units", hue="type",
                estimator=np.mean, err_style='band', errorbar=('ci', 95),
                col="speed_forward", kind="line", height=3, aspect=0.8)
g.set(ylabel="Acceleration (deg/s^2)")
plt.savefig('plots/fig2B_phase_accel_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/86334ac91cecd64e2b1eae60f287f2d7786204cd.png]]
[[file:./.ob-jupyter/2326bd059951cea6e2af3deccaf89b014be5c575.png]]
[[file:./.ob-jupyter/e35708320ccf5991ef5cfc91a29cd435c667d4c7.png]]
:END:



*** Supplementary plots - all the phase angle plots


not sure if it's worth including these to be honest? There are wayyy to many to show

#+BEGIN_SRC jupyter-python

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
def circular_mean(x):
    # return np.degrees(stats.circmean(np.radians(x), nan_policy='omit'))
    return np.degrees(np.angle(np.nanmean(np.exp(1j * np.radians(x)))))

def circular_mean_high(x):
    y = np.mod(circular_mean(x), 360)
    if y < 90:
        return y + 360
    else:
        return y

def circular_mean_low(x):
    y = np.mod(circular_mean(x), 360)
    if y > 270:
        return y - 360
    else:
        return y
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
def circular_ci(x):
    stderr = np.degrees(stats.circstd(np.radians(x), nan_policy='omit')) / np.sqrt(len(x))
    mean = circular_mean(x)
    interval = stderr * 1.96
    return (mean - interval, mean + interval)
#+END_SRC


#+RESULTS:



#+BEGIN_SRC jupyter-python
fullangf['leg_angle'] = fullangf['leg'] + fullangf['angle_name']
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
dd = fullangf
leg_angle = 'R2B_rot'
for leg_angle in tqdm(dd['leg_angle'].unique(), ncols=70):
    plt.close('all')

    c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
        & (dd['speed_forward'] > 5) & (dd['speed_forward'] < 15) \
        & (dd['leg_angle'] == leg_angle)
    fancy_name = leg_angle[:2] + '\n' + fancy_angle_names[leg_angle[2:]]
    g = sns.relplot(data=dd[c], x="phase", y="angle", hue="type",
                    estimator=circular_mean, err_style='band', errorbar=circular_ci,
                    col="speed_forward", kind="line", height=1.5, aspect=0.8)
    g.set(ylabel=fancy_name + "\nangle (deg)", title="", xlabel="")
    g.set(xticks=[-np.pi/2, 0, np.pi/2], xticklabels=[])
    plt.savefig('plots/suppfig2_phase_angle_{}.pdf'.format(leg_angle), bbox_inches = "tight")

    g = sns.relplot(data=dd[c], x="phase", y="deriv_units", hue="type",
                    estimator=np.mean, err_style='band', errorbar=('ci', 95),
                    col="speed_forward", kind="line", height=1.5, aspect=0.8)
    g.set(ylabel=fancy_name + "\nderivative (deg/s)", title="", xlabel="")
    g.set(xticks=[-np.pi/2, 0, np.pi/2], xticklabels=[])
    plt.savefig('plots/suppfig2_phase_deriv_{}.pdf'.format(leg_angle), bbox_inches = "tight")

# c = (dd['speed_side'].abs() <= 3) & (dd['speed_rotation'].abs() <= 3) \
#     & (dd['speed_forward'] > 5) & (dd['speed_forward'] < 15) \
#     & (dd['angle_name'] == angname) & (dd['leg'] == leg)
# g = sns.relplot(data=dd[c], x="phase", y="accel_units", hue="type",
#                 estimator=np.mean, err_style='band', errorbar=('ci', 95),
#                 col="speed_forward", kind="line", height=3, aspect=0.8)
# g.set(ylabel="Acceleration (deg/s^2)")
# plt.savefig('plots/fig2B_phase_accel_{}{}.pdf'.format(leg, angname), bbox_inches = "tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: 100%|█████████████████████████████████| 20/20 [03:47<00:00, 11.37s/it]
:
[[file:./.ob-jupyter/2a9d544cae0e94dd6fe602883e35248c54969c7e.png]]
[[file:./.ob-jupyter/4343e73e7cca54289d82d1a45d37f90f14598f2f.png]]
:END:





** Errors across angles
Need to run "Phase angle plots" section above to get the appropriate dataframes.

#+BEGIN_SRC jupyter-python
def circular_mean(x):
    # return np.degrees(stats.circmean(np.radians(x), nan_policy='omit'))
    return np.degrees(np.angle(np.nanmean(np.exp(1j * np.radians(x)))))

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
columns = ['leg', 'speed_forward', 'speed_rotation', 'speed_side', 'angle_name', 'phase']

ds = []
for var in ['angle', 'deriv', 'accel']:
    print(var)
    if var == 'angle':
        mean_fun = circular_mean
    else:
        mean_fun = np.nanmean
    sd = allangf.groupby(columns)[var].agg(mean_fun)
    rd = realangf.groupby(columns)[var].agg(mean_fun)
    out = sd - rd
    errors = out.reset_index().groupby(columns[:-1])[var]\
                              .agg(lambda x: np.abs(mean_fun(np.abs(x))))

    erange = rd.reset_index().groupby(columns[:-1])[var]\
                             .agg(lambda x: np.max(x) - np.min(x))

    percent_errors = (errors / erange) * 100.0

    errors = errors.reset_index()
    errors[var+'_percent'] = percent_errors.reset_index()[var]
    # errors = errors[~errors[var].isnull()]
    ds.append(errors)

angle_errors = pd.merge(pd.merge(ds[0], ds[1]), ds[2])

fancy_angle_names = {
    'C_flex': 'femur-tibia\nflexion',
    'A_rot': 'coxa\nrotation',
    'A_abduct': 'body-coxa\nflexion',
    'B_flex': 'coxa-femur\nflexion',
    'B_rot': 'femur\nrotation'
}
angle_errors['fancy_angle_name'] = [fancy_angle_names[x] for x in angle_errors['angle_name']]

angle_order = ['body-coxa\nflexion',
               'coxa\nrotation',
               'coxa-femur\nflexion',
               'femur\nrotation',
               'femur-tibia\nflexion']

angle_errors['deriv_units'] = angle_errors['deriv'] * 300.0
angle_errors['accel_units'] = angle_errors['accel'] * 300.0 * 300.0
#+END_SRC

#+RESULTS:
: angle
: /tmp/ipykernel_1250823/3407061830.py:3: RuntimeWarning: Mean of empty slice
:   return np.degrees(np.angle(np.nanmean(np.exp(1j * np.radians(x)))))
: deriv
: /tmp/ipykernel_1250823/2397220802.py:14: RuntimeWarning: Mean of empty slice
:   .agg(lambda x: np.abs(mean_fun(np.abs(x))))
: accel
: /tmp/ipykernel_1250823/2397220802.py:14: RuntimeWarning: Mean of empty slice
:   .agg(lambda x: np.abs(mean_fun(np.abs(x))))


#+BEGIN_SRC jupyter-python
plt.figure(figsize=(5, 4))
plt.subplot(1, 3, 1)
g = sns.violinplot(y='fancy_angle_name', x='angle', data=angle_errors,
                   hue=True, hue_order=[True, False], split=True, orient='h', color='black',
                   order=angle_order)
g.set(ylabel='Angle', xlabel='Angle\nerror (deg)')
g.legend_ = None

plt.subplot(1, 3, 2)
g = sns.violinplot(y='fancy_angle_name', x='deriv_units', data=angle_errors,
                   hue=True, hue_order=[True, False], split=True, orient='h', color='black')
g.set(ylabel='', xlabel='Derivative\nerror (deg/s)', yticklabels=[])
g.legend_ = None

plt.subplot(1, 3, 3)
g = sns.violinplot(y='fancy_angle_name', x='accel_units', data=angle_errors,
                   hue=True, hue_order=[True, False], split=True, orient='h', color='black')
g.set(ylabel='', xlabel='Acceleration\nerror (deg/s^2)', yticklabels=[])
g.legend_ = None

plt.savefig('plots/fig2C_error_raw_horizontal.pdf', bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/8ea2b767a899578ed33ccb0948ed4bd0b5c164e2.png]]

#+BEGIN_SRC jupyter-python
plt.figure(figsize=(6, 4))
ax = plt.subplot(2, 1, 1)
g = sns.violinplot(x='fancy_angle_name', y='angle', data=angle_errors, color='lightgray', cut=0, order=angle_order)
g.set(ylabel='Angle error (deg)', xlabel='')
plt.axhline(5.9, linestyle='dotted', color='gray')
ax.set_xticklabels([])
g.legend_ = None

plt.subplot(2, 1, 2)
g = sns.violinplot(x='fancy_angle_name', y='deriv_units', data=angle_errors, color='lightgray', cut=0, order=angle_order)
g.set(xlabel='Angle', ylabel='Derivative error (deg/s)')
# plt.axhline(5.9, linestyle='dotted', color='black')
g.legend_ = None

plt.savefig('plots/fig2C_error_raw_vertical.pdf', bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/3fe1d77241fade3a76578cbb3627c648b92d2f50.png]]


#+BEGIN_SRC jupyter-python :display plain
angle_errors.groupby(['leg', 'angle_name'])['angle'].mean()
#+END_SRC

#+RESULTS:
#+begin_example
leg  angle_name
L1   A_abduct       6.733312
     A_rot          7.463104
     B_flex         7.863317
     C_flex        10.876282
L2   B_flex         8.429925
     B_rot          4.416498
     C_flex         9.970893
L3   B_flex         9.664860
     B_rot          8.025939
     C_flex        10.223924
R1   A_abduct       7.177471
     A_rot          7.374859
     B_flex         8.506984
     C_flex        11.357676
R2   B_flex         5.466603
     B_rot          7.753377
     C_flex         7.594448
R3   B_flex         8.958846
     B_rot          6.436791
     C_flex         8.731250
Name: angle, dtype: float64
#+end_example


#+BEGIN_SRC jupyter-python
plt.figure(figsize=(2.5*3, 4))
plt.subplot(1, 3, 1)
g = sns.violinplot(y='fancy_angle_name', x='angle_percent', data=angle_errors, cut=0.2, bw=0.1,
                   hue=True, hue_order=[True, False], split=True, orient='h', color='black')
g.set(ylabel='Angle', xlabel='Angle\npercent error', xlim=(-1, 130))
g.legend_ = None

plt.subplot(1, 3, 2)
g = sns.violinplot(y='fancy_angle_name', x='deriv_percent', data=angle_errors, cut=1, bw=0.2,
                   hue=True, hue_order=[True, False], split=True, orient='h', color='black')
g.set(ylabel='', xlabel='Derivative\npercent error', yticklabels=[], xlim=(0, 50))
g.legend_ = None

plt.subplot(1, 3, 3)
g = sns.violinplot(y='fancy_angle_name', x='accel_percent', data=angle_errors, cut=1, bw=0.2,
                   hue=True, hue_order=[True, False], split=True, orient='h', color='black')
g.set(ylabel='', xlabel='Acceleration\npercent error', yticklabels=[], xlim=(0, 50))
g.legend_ = None

plt.savefig('plots/fig2C_error_percent.pdf', bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/b75fc13f7949a9eb2574219a9ebda74ed7be3d69.png]]



** supplementary errors

I'd like to add the heatmap plots of different speeds. I'm not sure how to convey all the errors at all the different speeds in a compact way.
Perhaps I could break down the violin plot by leg and by speed in two different plots.
- break down by leg
- break down by speed

I think that would make more sense than heatmap plots yah.

#+BEGIN_SRC jupyter-python
angle_errors = angle_errors[np.isfinite(angle_errors['angle'])]
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
plt.figure(figsize=(11, 4))
ax = plt.subplot(2, 1, 1)
g = sns.violinplot(x='fancy_angle_name', y='angle', hue='leg', data=angle_errors,  cut=0, order=angle_order)
g.set(ylabel='Angle error (deg)', xlabel='')
plt.axhline(5.9, linestyle='dotted', color='gray')
ax.set_xticklabels([])
g.legend_ = None

plt.subplot(2, 1, 2)
g = sns.violinplot(x='fancy_angle_name', y='deriv_units', hue='leg', data=angle_errors, cut=0, order=angle_order)
g.set(xlabel='Angle', ylabel='Derivative error (deg/s)')
# plt.axhline(5.9, linestyle='dotted', color='black')
plt.legend(ncol=6)
# g.legend_ = None

plt.savefig('plots/suppfig2_error_raw_byleg.pdf', bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/e4330d6615a96d490a487529d1b20f64a009fe53.png]]



#+BEGIN_SRC jupyter-python
plt.figure(figsize=(11, 4))
ax = plt.subplot(2, 1, 1)
g = sns.violinplot(x='fancy_angle_name', y='angle', hue='speed_forward', data=angle_errors,  cut=0, order=angle_order, palette='plasma')
g.set(ylabel='Angle error (deg)', xlabel='')
plt.axhline(5.9, linestyle='dotted', color='gray')
ax.set_xticklabels([])
g.legend_ = None

plt.subplot(2, 1, 2)
g = sns.violinplot(x='fancy_angle_name', y='deriv_units', hue='speed_forward', data=angle_errors, cut=0, order=angle_order, palette='plasma')
g.set(xlabel='Angle', ylabel='Derivative error (deg/s)')
# plt.axhline(5.9, linestyle='dotted', color='black')
plt.legend(ncol=2)
# g.legend_ = None

plt.savefig('plots/suppfig2_error_raw_speed_forward.pdf', bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/df852c60a1fea9c71a1c99d01e932676958d0514.png]]

#+BEGIN_SRC jupyter-python
plt.figure(figsize=(11, 4))
ax = plt.subplot(2, 1, 1)
g = sns.violinplot(x='fancy_angle_name', y='angle', hue='speed_side', data=angle_errors,  cut=0, order=angle_order, palette='Spectral')
g.set(ylabel='Angle error (deg)', xlabel='')
plt.axhline(5.9, linestyle='dotted', color='gray')
ax.set_xticklabels([])
g.legend_ = None

plt.subplot(2, 1, 2)
g = sns.violinplot(x='fancy_angle_name', y='deriv_units', hue='speed_side', data=angle_errors, cut=0, order=angle_order, palette='Spectral')
g.set(xlabel='Angle', ylabel='Derivative error (deg/s)')
# plt.axhline(5.9, linestyle='dotted', color='black')
plt.legend(ncol=5)
# g.legend_ = None
plt.savefig('plots/suppfig2_error_raw_speed_side.pdf', bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/414a1b980c22089c5ee5b352e77ca71419ee533e.png]]


#+BEGIN_SRC jupyter-python
plt.figure(figsize=(15, 4))
ax = plt.subplot(2, 1, 1)
g = sns.violinplot(x='fancy_angle_name', y='angle', hue='speed_rotation', data=angle_errors,  cut=0, order=angle_order, palette='Spectral')
g.set(ylabel='Angle error (deg)', xlabel='')
plt.axhline(5.9, linestyle='dotted', color='gray')
ax.set_xticklabels([])
g.legend_ = None

plt.subplot(2, 1, 2)
g = sns.violinplot(x='fancy_angle_name', y='deriv_units', hue='speed_rotation', data=angle_errors, cut=0, order=angle_order, palette='Spectral')
g.set(xlabel='Angle', ylabel='Derivative error (deg/s)')
# plt.axhline(5.9, linestyle='dotted', color='black')
plt.legend(ncol=2)
# g.legend_ = None

plt.savefig('plots/suppfig2_error_raw_speed_rotation.pdf', bbox_inches = "tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/ea9e54eb24df86005b8d25d0d03e3edce465c94c.png]]



** Supplementary - walking speed distributions

#+BEGIN_SRC jupyter-python
speed_names = ['forward velocity', 'rotation velocity', 'side velocity']
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
for i in range(3):
    _ = sns.histplot(wd.context[:, i], element='step', fill=False, bins=200,
                     label=speed_names[i])
sns.despine()
plt.legend()
plt.xlabel("Velocity (mm/s)")
plt.ylabel("Number of frames")
plt.savefig('plots/suppfig2_velocities_hist.pdf')
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/5b38a30cd6296fa5b39a23266759109f28a360a9.png]]

#+BEGIN_SRC jupyter-python
for i in range(3):
    _ = sns.histplot(wd.context[:, i], element='step', fill=False, stat='density',
                     cumulative=True, label=speed_names[i])
plt.legend()
sns.despine()
plt.xlabel("Velocity (mm/s)")
plt.ylabel("Cumulative probability")
plt.savefig('plots/suppfig2_velocities_cdf.pdf')
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/a7f306f54f75ad296449c650a68e7d11c33106ce.png]]


#+BEGIN_SRC jupyter-python
plt.figure(figsize=(3, 2))
plt.scatter(wd.context[:, 1], wd.context[:, 2], s=1, alpha=0.03)
plt.xlabel('Average rotation speed (mm/s)')
plt.ylabel('Average side speed\n(mm/s)')
sns.despine()
plt.savefig('plots/suppfig2_velocities_rotside_scatter.pdf')
plt.savefig('plots/suppfig2_velocities_rotside_scatter.png')
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/c7626b9af7426bdc7489d37d531e18cfef585428.png]]


* Figure 3
** Phase coupling within a leg - phase version


#+BEGIN_SRC jupyter-python
ds = []
for i in trange(len(speeds), ncols=70):
    forward, rot, side = speeds[i]
    d = pd.DataFrame()
    for ix_ang, angname in enumerate(angle_names):
        leg = angname[:2]
        x = np.vstack([angles[i][:, ix_ang],
                       derivs[i][:, ix_ang]]).T
        phase = get_phase(x)
        key = angname
        d[key] = phase
    d['speed_forward'] = forward
    d['speed_rotation'] = rot
    d['speed_side'] = side
    d['type'] = 'simulated'
    ds.append(d)
phases_byleg_sim = pd.concat(ds).reset_index(drop=True)
#+END_SRC

#+RESULTS:
:RESULTS:
:   5%|█▍                             | 73/1540 [00:02<00:45, 32.52it/s]
:
# [goto error]
#+begin_example
[0;31m---------------------------------------------------------------------------[0m
[0;31mKeyboardInterrupt[0m                         Traceback (most recent call last)
Cell [0;32mIn[43], line 9[0m
[1;32m      6[0m leg [38;5;241m=[39m angname[:[38;5;241m2[39m]
[1;32m      7[0m x [38;5;241m=[39m np[38;5;241m.[39mvstack([angles[i][:, ix_ang],
[1;32m      8[0m                derivs[i][:, ix_ang]])[38;5;241m.[39mT
[0;32m----> 9[0m phase [38;5;241m=[39m [43mget_phase[49m[43m([49m[43mx[49m[43m)[49m
[1;32m     10[0m key [38;5;241m=[39m angname
[1;32m     11[0m d[key] [38;5;241m=[39m phase

Cell [0;32mIn[42], line 7[0m, in [0;36mget_phase[0;34m(ang)[0m
[1;32m      5[0m s[s [38;5;241m==[39m [38;5;241m0[39m] [38;5;241m=[39m [38;5;241m1[39m
[1;32m      6[0m dm [38;5;241m=[39m (ang [38;5;241m-[39m m) [38;5;241m/[39m s
[0;32m----> 7[0m phase [38;5;241m=[39m [43mnp[49m[38;5;241;43m.[39;49m[43marctan2[49m[43m([49m[38;5;241;43m-[39;49m[43mdm[49m[43m[[49m[43m:[49m[43m,[49m[38;5;241;43m1[39;49m[43m][49m[43m,[49m[43m [49m[43mdm[49m[43m[[49m[43m:[49m[43m,[49m[38;5;241;43m0[39;49m[43m][49m[43m)[49m
[1;32m      8[0m [38;5;28;01mreturn[39;00m phase

[0;31mKeyboardInterrupt[0m:
#+end_example
:END:


#+BEGIN_SRC jupyter-python
ds = []
bnums = wd._get_minlen_bnums(400)
for i in trange(len(bnums), ncols=70):
    bnum = bnums[i]
    ww = wd.get_bnum(bnum)
    # mean_speed = np.mean(ww['contexts'], axis=0)
    # forward, rot, side = mean_speed
    d = pd.DataFrame()
    for ix_leg, leg in enumerate(legs):
        for ix_ang, angname in enumerate(wd._angle_names[leg]):
            x = np.vstack([ww['angles'][leg][:, ix_ang],
                           ww['derivatives'][leg][:, ix_ang]]).T
            phase = get_phase(x)
            key = angname
            d[key] = phase
    contexts = ww['contexts']
    d['speed_forward'] = contexts[:, 0]
    d['speed_rotation'] = contexts[:, 1]
    d['speed_side'] = contetxs[:, 2]
    d['type'] = 'real'
    ds.append(d)
phases_byleg_real = pd.concat(ds).reset_index(drop=True)
#+END_SRC

#+RESULTS:
:RESULTS:
:   0%|                                         | 0/173 [00:00<?, ?it/s]
:
# [goto error]
: [0;31m---------------------------------------------------------------------------[0m
: [0;31mNameError[0m                                 Traceback (most recent call last)
: Cell [0;32mIn[44], line 19[0m
: [1;32m     17[0m d[[38;5;124m'[39m[38;5;124mspeed_forward[39m[38;5;124m'[39m] [38;5;241m=[39m contexts[:, [38;5;241m0[39m]
: [1;32m     18[0m d[[38;5;124m'[39m[38;5;124mspeed_rotation[39m[38;5;124m'[39m] [38;5;241m=[39m contexts[:, [38;5;241m1[39m]
: [0;32m---> 19[0m d[[38;5;124m'[39m[38;5;124mspeed_side[39m[38;5;124m'[39m] [38;5;241m=[39m [43mcontetxs[49m[:, [38;5;241m2[39m]
: [1;32m     20[0m d[[38;5;124m'[39m[38;5;124mtype[39m[38;5;124m'[39m] [38;5;241m=[39m [38;5;124m'[39m[38;5;124mreal[39m[38;5;124m'[39m
: [1;32m     21[0m ds[38;5;241m.[39mappend(d)
:
: [0;31mNameError[0m: name 'contetxs' is not defined
:END:

#+BEGIN_SRC jupyter-python
phases_byleg = pd.concat([phases_byleg_sim, phases_byleg_real])
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
d = phases_byleg
fig, subplots = plt.subplots(6, 5, figsize=(9, 1.5*6))
for ix_leg, leg in enumerate(legs):
    if leg in ['L2', 'R2']:
        refname = 'B_rot'
    else:
        refname = 'C_flex'
    for ix_ang, angname in enumerate(sorted(angle_names_1leg)):
        ax = subplots[ix_leg][ix_ang]
        if angname == refname:
            if ix_leg == 0:
                ax.set_title(fancy_angle_names[angname])
            ax.set_axis_off()
            continue

        if leg + angname not in d:
            ax.set_axis_off()
        else:
            d = phases_byleg[phases_byleg['type'] == 'simulated']
            sns.kdeplot(np.mod(d[leg + angname] - d[leg + refname] + np.pi, 2*np.pi)-np.pi,
                        cut=0, fill=True, ax=ax)
            d = phases_byleg[phases_byleg['type'] == 'real']
            sns.kdeplot(np.mod(d[leg + angname] - d[leg + refname] + np.pi, 2*np.pi)-np.pi,
                        cut=0, fill=True, ax=ax)
            ax.set_ylim(0, 1.5)

        if ix_leg == 0:
            ax.set_title(fancy_angle_names[angname])
        if ix_ang == 0:
            ax.set_ylabel(leg + "\nProbability density")
        else:
            ax.set_yticklabels([])
            ax.set_ylabel("")
        if ix_leg != 5:
            ax.set_xticklabels([])

plt.savefig("plots/fig3A_phases_withinleg.pdf", bbox_inches = "tight")
#+END_SRC

#+RESULTS:
#+begin_example

KeyboardInterrupt

Error in callback <function _draw_all_if_interactive at 0x7fd0babbb9d0> (for post_execute):

KeyboardInterrupt

Error in callback <function flush_figures at 0x7fd08bb36f70> (for post_execute):

KeyboardInterrupt
#+end_example

** Phase coupling across legs

How to demonstrate the phase coupling across the legs?
I guess we extract the phase from each leg, and compute the difference mod 2 pi?

#+BEGIN_SRC jupyter-python
# compute phase
def get_phase(ang):
    m = np.median(ang, axis=0)
    s = np.std(ang, axis=0)
    s[s == 0] = 1
    dm = (ang - m) / s
    phase = np.arctan2(-dm[:,1], dm[:,0])
    return phase

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
ds = []
for i in trange(len(speeds), ncols=70):
    d = pd.DataFrame()
    forward, rot, side = speeds[i]
    for ix_leg, leg in enumerate(legs):
        if leg in ['L2', 'R2']:
            phaseang = 'B_rot'
        else:
            phaseang = 'C_flex'
        ix_ang_phase = angle_names.index(leg + phaseang)
        x = np.vstack([angles[i][:, ix_ang_phase],
                       derivs[i][:, ix_ang_phase]]).T
        phase = get_phase(x)
        d['phase_' + leg] = phase
    d['speed_forward'] = forward
    d['speed_rotation'] = rot
    d['speed_side'] = side
    d['type'] = 'simulated'
    ds.append(d)
phased_sim = pd.concat(ds).reset_index(drop=True)
#+END_SRC

#+RESULTS:
: 100%|█████████████████████████████| 1540/1540 [00:19<00:00, 80.41it/s]
:


#+BEGIN_SRC jupyter-python
ds = []
bnums = wd._get_minlen_bnums(400)
for i in trange(len(bnums), ncols=70):
    bnum = bnums[i]
    ww = wd.get_bnum(bnum)
    d = pd.DataFrame()
    for ix_leg, leg in enumerate(legs):
        if leg in ['L2', 'R2']:
            phaseang = 'B_rot'
        else:
            phaseang = 'C_flex'
        ix_ang_phase = wd._angle_names[leg].index(leg + phaseang)
        x = np.vstack([ww['angles'][leg][:, ix_ang_phase],
                       ww['derivatives'][leg][:, ix_ang_phase]]).T
        phase = get_phase(x)
        d['phase_' + leg] = phase

    contexts = ww['contexts']
    d['speed_forward_raw'] = contexts[:, 0]
    d['speed_rotation_raw'] = contexts[:, 1]
    d['speed_side_raw'] = contexts[:, 2]
    d['bnum'] = bnum
    d['type'] = 'real'
    ds.append(d)
phased_real = pd.concat(ds).reset_index(drop=True)

phased_real['speed_forward'] = ((phased_real['speed_forward_raw'] + 1) // 2) * 2
phased_real['speed_rotation'] = ((phased_real['speed_rotation_raw'] + 2) // 4) * 4
phased_real['speed_side'] = ((phased_real['speed_side_raw'] + 1) // 2) * 2
phased_real['speed_forward'] = phased_real['speed_forward'].astype('int')
phased_real['speed_rotation'] = phased_real['speed_rotation'].astype('int')
phased_real['speed_side'] = phased_real['speed_side'].astype('int')
#+END_SRC

#+RESULTS:
: 100%|███████████████████████████████| 173/173 [00:02<00:00, 73.81it/s]
:


#+BEGIN_SRC jupyter-python
phased = pd.concat([phased_sim, phased_real]).reset_index(drop=True)

# Add pi to correct for offset due to the way we compute the phase
phased['phase_L1'] += np.pi
phased['phase_R1'] += np.pi
phased['phase_R2'] += np.pi
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
fig, subplots = plt.subplots(6, 6, figsize=(8, 8))
for i, leg_i in enumerate(legs):
    for j, leg_j in enumerate(legs):
        if i == j:
            ax = subplots[i][j]
            ax.text(0.4, 0.4, leg_i, fontsize="xx-large")
            ax.set_axis_off()
            continue
        ax = subplots[i][j]
        d = phased[phased['type'] == 'simulated']
        sns.kdeplot(np.mod(d['phase_'+leg_i] - d['phase_'+leg_j], 2*np.pi), cut=0, bw_method=0.1,
                    fill=True, ax=ax)
        d = phased[phased['type'] == 'real']
        sns.kdeplot(np.mod(d['phase_'+leg_i] - d['phase_'+leg_j], 2*np.pi), cut=0, bw_method=0.1,
                    fill=True, ax=ax)
        ax.set_xlim(0, 2*np.pi)
        ax.set_ylim(0, 0.6)
        ax.set_ylabel("")
        ax.set_xticks([np.pi])
        ax.set_yticks([0.3])
        if i != 5:
            ax.set_xticklabels([])
        if j != 0:
            ax.set_yticklabels([])

fig.savefig('plots/fig3B_phases_legs.pdf', bbox_inches = "tight")
#+END_SRC

#+RESULTS:
: 3af04e64-b432-4ae0-b488-2d41264a7442



#+BEGIN_SRC jupyter-python
pp = phasesTG[10]
plt.plot(np.mod(pp[1] - pp[5], 2*np.pi))
# _ = plt.hist(np.mod(2*np.pi - (pp[2] - pp[5]), 2*np.pi), bins=50)
#+END_SRC

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7fdcbd3ac580> |
[[file:./.ob-jupyter/c5695e2cccdd4c914d26f1c804c73d694f38cd14.png]]
| <matplotlib.lines.Line2D | at | 0x7fdc3d8429d0> |
[[file:./.ob-jupyter/c5695e2cccdd4c914d26f1c804c73d694f38cd14.png]]
:END:


** Phase offsets across speeds

#+BEGIN_SRC jupyter-python
preal = phased[phased['type'] == 'real'].copy()
preal['speed_forward_4'] = (((preal['speed_forward_raw'] + 2) // 4) * 4).astype('int')
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
speeds_forward = [4, 8, 12, 16]
speeds_rotation = [-12, -8, -4, 0, 4, 8, 12]
speeds_side = phased_sim['speed_side'].unique()
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
rows = []

for s_f in speeds_forward:
    for s_r in speeds_rotation:
        check = (preal['speed_forward_4'] == s_f) & \
            (preal['speed_rotation'] == s_r)
        if np.sum(check) == 0:
            continue
        sub = preal[check]

        row = {'speed_forward': s_f,
               'speed_rotation': s_r,
               # 'speed_side': s_s,
               'num': len(sub),
               }

        for leg_1 in legs:
            for leg_2 in legs:
                key = 'diff_{}_{}'.format(leg_1, leg_2)
                diff = np.mod(sub['phase_'+leg_1].values -
                              sub['phase_'+leg_2].values, 2*np.pi)
                mm = np.mean(np.exp(1j * diff))
                mean = np.mod(np.angle(mm), 2*np.pi)
                std = np.sqrt(-2 * np.log(np.abs(mm)))
                row[key + '_mean'] = mean
                row[key + '_std'] = std
        rows.append(row)

mean_offsets = pd.DataFrame(rows)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
cmap = plt.get_cmap('plasma')
norm = plt.Normalize(4, 18)
plt.figure(figsize=(6,6))
for i in range(6):
    for j in range(6):
        plt.subplot(6, 6, i*6+j+1)
        if i == j:
            plt.text(0.4, 0.4, legs[i], fontsize="xx-large")
            plt.axis('off')
            continue
        key = 'diff_{}_{}_mean'.format(legs[i], legs[j])
        for s_f in speeds_forward:
            check = (mean_offsets['speed_forward'] == s_f)
            means = np.array(mean_offsets.loc[check, key])
            means[means > np.pi * 1.55] -= 2*np.pi
            s_r = mean_offsets.loc[check, 'speed_rotation'].values
            ix = np.argsort(s_r)
            plt.plot(s_r[ix], means[ix], color=cmap(norm(s_f)))
        if j != i+1:
            ax = plt.gca()
            ax.set_yticklabels([])
            ax.set_xticklabels([])
        # plt.ylim(-0.75, 0.75)
        plt.ylim(-np.pi / 2, 2*np.pi)
sns.despine()
plt.savefig('plots/suppfig3_phase_offsets_speeds.pdf')
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/69a10f239d6506c2698672efdbf398d5fb3e0a4b.png]]
